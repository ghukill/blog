<h1>2017-01-23-handling-repeating-GET-params</h1>
<pre><code>{
  "published": true
}</code></pre>
<p>Re: the last couple of posts about repeating GET parameters, and how PHP is slightly unconventional in how it parses.  Came up with a solution: a <code>QueryBuilder</code> class.</p>
<p><img alt="IMG_20170123_140040.jpg" src="images/IMG_20170123_140040.jpg" /></p>
<p>It was a particularly pernicious problem, and time will tell how well our solution scales and evolves.  The problem came down to how the <a href="https://www.slimframework.com/">Slim PHP framework</a> parsed GET parameters, and the <a href="http://docs.guzzlephp.org/en/latest/">Guzzle PHP client</a> encoded <code>GET</code> requests.  </p>
<p>Slim used the built-in PHP function, <a href="http://php.net/manual/en/function.parse-str.php"><code>parse_str</code></a> that followed the PHP convention to <em>only</em> capture repeating <code>GET</code> parameters when the <code>GET</code> parameter string contained square brackets <code>[]</code> around those repeating fields.  For example: </p>
<p><code>?fq=foo&amp;fq=bar</code> would get truncated to <code>'fq'=&gt;'bar'</code></p>
<p>However, if square brackets were used, repeating values would get picked up from <code>?fq[]=foo&amp;fq[]=bar</code>, and become <code>'fq'=['foo','bar']</code>.</p>
<p>So, we needed to always send requests to our <code>/search</code> route with square brackets.  But we did not want to the indices that <a href="http://php.net/manual/en/function.http-build-query.php"><code>http_build_query</code></a> includes when building a <code>GET</code> param string, as that would hurt our ability to manipulate the URL by cherry-picking known parameters to remove.  </p>
<p>Speaking of <code>http_build_query</code>, this is what Guzzle uses to build <code>GET</code> parameters for an HTTP request.  As alluded to above, an associative array like <code>'fq'=['foo','bar']</code>, would result in the following string, <code>?fq[0]=foo&amp;fq[1]=bar</code>. </p>
<p>This was also not ideal, as our API is not prepared to handle <code>fq[n]</code> fields of an unknown <code>n</code> quantity.  The <a href="http://stackoverflow.com/questions/41746785/regex-in-requestparser-for-python-flask-restful">verdict is still out if/how python Flask-RESTful can handle that kind of regex parsing</a>.</p>
<p>So, we needed to fix HTTP requests on the way out too.  The end result was <strong>two</strong> places in a typical advanced query that required <code>GET</code> parameter fixing.  We created a <code>QueryBuilder</code> class that is invoked where and when needed, to prepare I/O <code>GET</code> parameters.  The best part is, this class has become a logical place to house any complex behavior related to search and query parameter parsing and prepping.</p>
<p>So what is this thing?  When does <code>QueryBuilder</code> become a thing unto itself?  Why can't Guzzle optionally not include indices in HTTP request when passed an associative array as parameters?  Why can't Slim parse a route with repeating <code>GET</code> parameters that don't have square brackets?</p>
<p>These are the questions that make all of this occassionaly frustrating, but always interesting.  Observing that libraries we use to parse and prepare HTTP requests were following conventions incompatible with components up <em>and</em> downstream, it prompted the creation of a class that is proving to be supremely helpful.</p>